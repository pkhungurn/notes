\documentclass[10pt]{article}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage[amsthm, thmmarks]{ntheorem}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{enumerate}
\usepackage{bussproofs}

\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}[lemma]{Theorem}
\newtheorem{definition}[lemma]{Definition}
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{claim}[lemma]{Claim}

\newcommand{\dee}{\mathrm{d}}
\newcommand{\In}{\mathrm{in}}
\newcommand{\Out}{\mathrm{out}}
\newcommand{\pdf}{\mathrm{pdf}}
\newcommand{\Ei}{\mathrm{Ei}}
\newcommand{\Tri}{\mathbf{tri}}
\newcommand{\Th}{\mathbf{th}}
\newcommand{\V}{\mathbf{V}}
\newcommand{\Const}{\mathbf{const}}

\newcommand{\ve}[1]{\mathbf{#1}}
\newcommand{\mrm}[1]{\mathrm{#1}}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\msf}[1]{\mathsf{#1}}
\newcommand{\ra}{\rightarrow}
\newcommand{\Bool}{\mathrm{Bool}}

\title{Simply Typed Lambda Calculus}
\author{Pramook Khungurn}

\begin{document}
	\maketitle
	
	This handout follows Pierce's treatment of simply typed lambda calculus. We'll go over simpler typed lambda calculus
	over the type $\mrm{Bool}$ and its normalization property.
  
	\section{Typing Relation}
	
	\begin{itemize}
	  \item There are two types of objects we are dealing with.
	  \begin{itemize}
	    \item The first are {\bf terms}, which are lambda terms.
	    \item The second are {\bf types}, which can be thought of as sets of terms with certain properties.
	  \end{itemize}
	  
	  \item A {\bf typing relation} is the relation $t : T$, where $t$ is a term and $T$ is a type.\\
	  It means $t$ \emph{obviously} evaluates to a value of an appropriate form.\\	
	  We should be able to \emph{statically} see this relation without doing any evaluation of $t$.
	  
	  \item Most typing relations are \emph{conservatitve}. They can only make use of dynamic information.\\
	  For example, we would not be able to determine type of $\msf{if}\ \msf{true}\ \msf{then}\ 0\ \msf{else}\ \msf{false}$
	  although the evalution gives you only one possible value.
	  
	  \item A typing relation is defined as the smallest binary relation that satisfies a number 
	    of inference rules assigning types to terms.
	  
	  \item A term $t$ is {\bf typable}	(or {\bf well typed}) if there is some type $T$ such that $t : T$.
	  
	  \item We want our type system to be {\bf safe}. This means they have the following two properties:
	    \begin{itemize}
	      \item {\bf Progress}. A well-typed term is not stuck.\\
	      That is, it is either a value, or a term which has an evaluation rule it can take to proceed.
	      \item {\bf  Preservation}. If a well-typed term takes an evaluation step, the resulting term
	      is also well typed.
	    \end{itemize}	    
	\end{itemize}
	
	\section{Simple Types over $\mrm{Bool}$}
	
	  \begin{itemize}
	    \item The set of {\bf simple types} over $\mrm{Bool}$ is generated by the following rules:
	    \begin{itemize}
	      \item $\mrm{Bool}$ itself is a simple type over $\mrm{Bool}$.
	      \item If $T_1$ and $T_2$ are simple types over $\mrm{Bool}$, then $T_1 \rightarrow T_2$ is a simple
	        types over $\mrm{Bool}$.
	    \end{itemize}	  	    
	    \item The type constructor $\rightarrow$ is right-associative.\\
	      The expression $T_1 \rightarrow T_2 \rightarrow T_3$ means $T_1 \rightarrow (T_2 \rightarrow T_3)$.
	      
	    \item The interpretation is that $T_1 \ra T_2$ is the type of functions that takes in input of
	      type $T_1$ and maps it to an output of type $T_2$.
	      
	      For example, $\Bool \ra \Bool$ is the function that takes a boolean and spits out a boolean.
	      Let us call this type the type of boolean function.
	      
	      $(\Bool \ra \Bool) \ra \Bool \ra \Bool$ is a funtion that takes a boolean function
	      and spits out another boolean function.
	      
	    \item We will annotate the argument to the lambda term with the type it's supposed to have.
	      For example, we will write $\lambda x: T.\ t$ instead of just $\lambda x.\ t.$
	      
	    \item Languages in which type annotations are used to help guide the typechecker are called
	      {\bf explicitly typed}. Languages in which we ask the typechecker to infer this information
	      is called {\bf implicitly typed}.
	      
	    \item When typing an abstraction $\lambda x : T_1.\ t_2$, the type of the abstraction
	      is the type $T_2$ that you get when you assume that all the occurence of type $x$ in $t_2$
	      is of type $T_1$.
	      
	      This is captured by the following inference rule:
	      \begin{prooftree}
	        \AxiomC{$x:T_1 \vdash t_2:T_2$ }
	        \UnaryInfC{$\vdash \lambda x : T_1.\ t_2 : T_1 \ra T_2$}
	      \end{prooftree}
	      
	    \item The notation $\Gamma \vdash t : T$ is used to denote a three-place relation where (1) $\Gamma$
	      is a set of assumptions, (2) $t$ is a term, and (3) $T$ is a type. It means that if $\Gamma$ holds,
	      then $t$ has type $T$.
	      
	      When the set of assumptions is the empty set, we would just right $\vdash t : T$.
	      
	    \item Most of the times, $\Gamma$ will have the form $x_1 : T_1, x_2 : T_2, \dotsc, x_n : T_n$.
	      So we can think of $\Gamma$ as a function that maps variables to their types.	      
	      As such, we can use $\mrm{dom}(\Gamma)$ to denote the variables bound by $\Gamma$.
	      
	    \item The rule of typing abstraction has the following general form:
	      \begin{prooftree}
	        \AxiomC{$\Gamma, x:T_1 \vdash t_2:T_2$ }
	        \UnaryInfC{$\Gamma, \vdash \lambda x : T_1.\ t_2 : T_1 \ra T_2$}
	      \end{prooftree}
	      
	    \item A variable has the type that we assume it to have:
	      \begin{prooftree}
	        \AxiomC{$x:T \in \Gamma$}
	        \UnaryInfC{$\Gamma \vdash x:T$}
	      \end{prooftree}
	      
	    \item Here is the typing rule for application:
	      \begin{prooftree}
	        \AxiomC{$\Gamma \vdash t_1 : T_{11} \rightarrow T_{12}$}
	        \AxiomC{$\Gamma \vdash t_2 : T_{11}$}
	        \BinaryInfC{$\Gamma \vdash (t_1\ t_2) : T_{12}$}
	      \end{prooftree}
	      
	    \item Lastly, here is the typing rule for the if statement:
	      \begin{prooftree}
	        \AxiomC{$\Gamma \vdash t_1 : \Bool$}
	        \AxiomC{$\Gamma \vdash t_2 : T$}
	        \AxiomC{$\Gamma \vdash t_3 : T$}
	        \TrinaryInfC{$\Gamma \vdash (\msf{if}\ t_1\ \msf{then}\ t_2\ \msf{else}\ t_3) : T$}
        \end{prooftree}
    \end{itemize}
    
  \section{Properties of Typing}
\end{document}